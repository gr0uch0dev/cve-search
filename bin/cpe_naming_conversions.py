import xml.etree.ElementTree as ET
#from bin.search import search_product
def search_product():
    pass

import re
import os
import pandas as pd
_xml_cpe_dictionary = None


def get_cpe_dictionary_xlm():
    global _xml_cpe_dictionary
    assert _xml_cpe_dictionary is not None
    return _xml_cpe_dictionary


def set_cpe_dictionary_xml_path(xml_path):
    global _xml_cpe_dictionary
    _xml_cpe_dictionary = xml_path


def extract_full_names_to_cpe(xml_path):
    tree = ET.parse(xml_path)
    root = tree.getroot()
    all_elements_with_cpe_item_in_tag = [x for x in root.iter() if "cpe-item" in x.tag]
   # new_title_cpe = [([y for y in list(x) if "title" in y.tag][0].text,x.get("name")) for x in all_elements_with_cpe_item_in_tag]
    # return [(name,cpe23)]
    return [(cpe_element_title(x),cpe_element_cpe_2_2_name(x)) for x in all_elements_with_cpe_item_in_tag]


def cpe_element_title(element):
    return [y for y in list(element) if "title" in y.tag][0].text


def cpe_element_cpe_2_3_name(element):
    return [y for y in list(element) if "cpe23" in y.tag][0].get('name')


def cpe_element_cpe_2_2_name(element):
    return element.get('name')



_tuples_title_cpe = None


def load_info_from_xml(xml_path):
    global _tuples_title_cpe
    _tuples_title_cpe = extract_full_names_to_cpe(xml_path)


def from_full_software_info_get_cep_text(software_name, software_version, force_lookup=False):
    global _tuples_title_cpe
    assert isinstance(_tuples_title_cpe, list)
    cpe_found_from_current_dataset = use_software_name_and_version_to_get_cpe_info_from_available_dataset(software_name,software_version)
    if not cpe_found_from_current_dataset:
        if not force_lookup:
            return None
        return logic_lookup(software_name, software_version)
    if len(cpe_found_from_current_dataset) == 1:
        return cpe_found_from_current_dataset[0]
    return get_input_from_user(software_name, software_version,results_got=cpe_found_from_current_dataset)


def use_software_name_and_version_to_get_cpe_info_from_available_dataset(software_name, software_version):
    global _tuples_title_cpe
    filtered_by_name = [x for x in _tuples_title_cpe if software_name.lower() in x[0].lower()]
    # software version maybe to long
    steps = len(software_version)
    while steps:
        version_num = software_version[:steps+1]
        filtered_by_version = [x for x in filtered_by_name if x[1].split(":")[4] == version_num]
        if len(filtered_by_version) > 0:
            return filtered_by_version
        steps -= 1


def search_cve_from_full_software_name_and_version(software_info):
    cpe_name = from_full_software_info_get_cep_text(software_info)
    out = search_product(cpe_name)
    print(out)


def get_list_of_softwares_with_full_name_and_version(file_path):
    df_input = pd.read_csv(file_path, encoding="utf-16")
    df_input["Name_cleaned"] = df_input.apply(lambda x: re.sub(r"-\s*$","",x["Name"].replace(x["Version"],"")),axis=1)
    return list((df_input["Name_cleaned"] + "___" + df_input["Version"]).values)


def logic_lookup(software_name, software_version):
    global _tuples_title_cpe
    print(f"WARNING!!! The full software name: '{software_name}' was not found in the provided DB.")
    print("Trying to relax the searching query....")
    name_splits = software_name.split()
    if len(name_splits) == 1:
        return None # nothing to try
   # nums_of_words_matching_from_start = [sum([a==name_splits[i] for i,a in enumerate(x[0].split()) if i < len(name_splits)]) for x in _tuples_title_cpe]
    num_words_to_compare = len(name_splits) - 1
    cpe_found = False
    print(f"Starting from: {software_name}")
    print(f"Words that comprise it {name_splits}")
    print("We try to find the match removing one word at a time starting from the rightmost one.")
    potential_results = None
    # too many products that start with microsoft STH
    minimum_number_of_words = 3 if re.match("\s*microsoft", software_name.lower()) else 2
    while not cpe_found and num_words_to_compare >= minimum_number_of_words:
        print(f"Considering {num_words_to_compare} words! Namely:")
        print(f"{' '.join(name_splits[:num_words_to_compare])}")
        filtered_values = [x for x in _tuples_title_cpe if ' '.join(name_splits[:num_words_to_compare]) in x[0]]
        if len(filtered_values) > 0:
            potential_results = filtered_values
            cpe_found = True
        num_words_to_compare -= 1

    if cpe_found:
        print("We have found potential software.")
        print("Please follow the instructions.")
    return get_input_from_user(software_name, software_version, potential_results, forced_lookup=True)





def get_list_of_sw_with_cpe(software_list):
    not_transformed = []
    res = []
    for software_info in software_list:
        software_name = software_info.split("___")[0]
        software_version = software_info.split("___")[1]
        cpe_text = from_full_software_info_get_cep_text(software_name, software_version,force_lookup=False)


        if cpe_text:
            # force cpe 2.3
            cpe_value = force_cpe_2_3_format(cpe_text[1])
            res.append((software_name,software_version,cpe_value))
    return res


from urllib.parse import unquote
def force_cpe_2_3_format(input_text):
    # decode if url encoded chars
    # TODO revisit and testing
    input_text = unquote(input_text)
    input_text = input_text.replace("cpe:/a","cpe:2.3:a")
    input_text = re.sub(r"~(?=\w)", ":*:",input_text)
    input_text = input_text.replace("::",":*").replace("~",":*")
    return input_text



def repeatOnError(*exceptions):
    def checking(function):
        def checked(*args, **kwargs):
            while True:
                try:
                    result = function(*args, **kwargs)
                except exceptions as problem:
                    print("There was a problem with the input:")
                    print(problem.__class__.__name__)
                    print(problem)
                    print("Please repeat!")
                else:
                    return result
        return checked
    return checking


@repeatOnError(ValueError)
def get_input_from_user(software_name, software_version, results_got=None, forced_lookup=False):
    global _tuples_title_cpe
    print("\n\n\n")
    print(f"{'='*40}")
    print(f"{'='*40}")
    print(f"{'='*40}")
    print("\n\n\n")
    if not results_got:
        print_w(f"Nothing was found about the software '{software_name}' version: '{software_version}'")
        user_choice = int(input("Please enter 0 to skip this software or 1 to manually insert the cpe: "))
        if user_choice not in [0,1]:
            raise ValueError
        if user_choice == 1:
            user_cpe = input("Please enter 'vendor:product:version': ")
            filtered_list = [x[1] for x in _tuples_title_cpe if user_cpe in x[1]]
            if not filtered_list:
                raise ValueError("cpe not found! Try again!")
            return filtered_list[0]
        if user_choice == 0:
            return None
    if forced_lookup:
        print_w(f"The program was not able to find a cpe about the software '{software_name}' version: '{software_version}'!")
        print("But relaxing the query by removing some words from the software name,"
              " the program found potential values in the dataset that may suit")
    else:
        print_w(f"For the software '{software_name}' version: '{software_version}' more than one cpes have been found."
              f"Potential values follow:")
    print("\n".join([f"[{i+1}]-{x}" for i, x in enumerate(results_got)]))
    print(f"Please if you find a match for '{software_name}' version: '{software_version}'"
          f" insert one of the above numbers.\nIf you want to skip this software, please enter 0\n"
          f"If you want to write the cpe manually, please enter 'cpe'")
    user_choice = input("Your choice: ")
    if user_choice.isdigit():
        if int(user_choice) not in range(len(results_got)+1):
            raise ValueError("Number inserted not valid!")
        if int(user_choice) == 0:
            return None
        return results_got[int(user_choice)-1]
    if user_choice!='cpe':
        raise ValueError
    user_cpe = input("Please enter 'vendor:product:version': ")
    filtered_list = [x[1] for x in _tuples_title_cpe if user_cpe in x[1]]
    if not filtered_list:
        raise ValueError("cpe not found! Try again!")
    return filtered_list[0]


def print_w(input_text):
    print(f"{Colors.WARNING}" + input_text + f"{Colors.ENDC}")


class Colors:
    HEADER = '\033[95m'
    OKBLUE = '\033[94m'
    OKCYAN = '\033[96m'
    OKGREEN = '\033[92m'
    WARNING = '\033[93m'
    FAIL = '\033[91m'
    ENDC = '\033[0m'
    BOLD = '\033[1m'
    UNDERLINE = '\033[4m'

def get_header_for_user_input():
    pass


tmp = """CVE	: CVE-2010-3190
DATE	: 2010-08-31 20:00:00
CVSS	: 9.3
Untrusted search path vulnerability in the Microsoft Foundation Class (MFC) Library in Microsoft Visual Studio .NET 2003 SP1; Visual Studio 2005 SP1, 2008 SP1, and 2010; Visual C++ 2005 SP1, 2008 SP1, and 2010; and Exchange Server 2010 Service Pack 3, 2013, and 2013 allows local users to gain privileges via a Trojan horse dwmapi.dll file in the current working directory during execution of an MFC application such as AtlTraceTool8.exe (aka ATL MFC Trace Tool), as demonstrated by a directory that contains a TRC, cur, rs, rct, or res file, aka "MFC Insecure Library Loading Vulnerability." Per: https://technet.microsoft.com/en-us/security/bulletin/ms11-025 Access Vector: Network per "This is a remote code execution vulnerability" Per: http://cwe.mitre.org/data/definitions/426.html

CWE-426: Untrusted Search Path

References:
-----------
http://lists.apple.com/archives/security-announce/2015/Sep/msg00003.html
http://secunia.com/advisories/41212
http://www.corelan.be:8800/index.php/2010/08/25/dll-hijacking-kb-2269637-the-unofficial-list/
http://www.securityfocus.com/bid/42811
http://www.us-cert.gov/cas/techalerts/TA11-102A.html
https://docs.microsoft.com/en-us/security-updates/securitybulletins/2011/ms11-025
https://oval.cisecurity.org/repository/search/definition/oval%3Aorg.mitre.oval%3Adef%3A12457
https://portal.msrc.microsoft.com/en-US/security-guidance/advisory/CVE-2010-3190
https://support.apple.com/HT205221

Vulnerable Configs:
-------------------
cpe:2.3:a:apple:itunes:12.1.3:*:*:*:*:*:*:*
cpe:2.3:a:microsoft:visual_c\+\+:2005:sp1:*:*:redistributable_package:*:*:*
cpe:2.3:a:microsoft:visual_c\+\+:2008:sp1:*:*:redistributable_package:*:*:*
cpe:2.3:a:microsoft:visual_c\+\+:2010:sp1:*:*:redistributable_package:*:*:*
cpe:2.3:a:microsoft:visual_studio:2005:sp1:*:*:*:*:*:*
cpe:2.3:a:microsoft:visual_studio:2008:sp1:*:*:*:*:*:*
cpe:2.3:a:microsoft:visual_studio:2010:-:*:*:*:*:*:*
"""

import subprocess
if __name__ == "__main__":
    os.chdir('../')
    print("Starting ....")
    cpe_dataset = os.path.join("data", "official-cpe-dictionary_v2.2.xml")
    # parameter
    software_list_path = os.path.join("data", "installed_progs.txt")
    print(f"Getting software lists from: {software_list_path}")
    software_lists = get_list_of_softwares_with_full_name_and_version(software_list_path)
    print(f"Loading the cpe dataset: {cpe_dataset}")
    load_info_from_xml(cpe_dataset)
    print(f"Dataset about cpes successfully loaded.")
    print("\n\n\n")
    print("Trying to convert software names and version into correct cpes.")
    cpe_info = get_list_of_sw_with_cpe(software_lists)
    #cpe_names = [from_full_software_info_get_cep_text(x) for x in software_lists]
    print("We are going to search for the following list of software:")
    print("\n".join([f"{x}" for x in cpe_info]))
    res = []
    for info in cpe_info:
        sw_name = info[0]
        sw_version = info[1]
        cpe_2_3 = info[2]
        cve_cvss = None
        out = subprocess.check_output(["/app/bin/search.py","-p",f"{cpe_2_3}"])
        if out:
            match_cve = re.findall(r"(?<=CVE\t:\s)CVE-\d+-\d+", out.decode())
            match_cvss = re.findall(r"CVSS\s*:\s*\d\.*\d*", out.decode())
            assert len(match_cve) == len(match_cvss)
            cve_cvss = [f"{x}({y})".replace("\t","") for x,y in zip(match_cve, match_cvss)]
        res.append({"Software": f"{sw_name}", "Version:":f"{sw_version}",
                       "CVE(CVSS)":None if not cve_cvss else " ".join(cve_cvss)})
    df = pd.DataFrame.from_dict(res)
    print("Output produced!")
    df.to_excel("out.xlsx")


    debug = True
