import xml.etree.ElementTree as ET
#from bin.search import search_product
def search_product():
    pass

import re
import os
import pandas as pd
_xml_cpe_dictionary = None


def get_cpe_dictionary_xlm():
    global _xml_cpe_dictionary
    assert _xml_cpe_dictionary is not None
    return _xml_cpe_dictionary


def set_cpe_dictionary_xml_path(xml_path):
    global _xml_cpe_dictionary
    _xml_cpe_dictionary = xml_path


def extract_full_names_to_cpe(xml_path):
    tree = ET.parse(xml_path)
    root = tree.getroot()
    tag_item = [x.tag for x in root.iter() if "cpe-item" in x.tag][0]
    tag_title = [x.tag for x in root.iter() if "title" in x.tag][0]
    title_cpe = [(x.find(tag_title).text, x.get("name")) for x in root.findall(tag_item)]
    return title_cpe


_tuples_title_cpe = None


def load_info_from_xml(xml_path):
    global _tuples_title_cpe
    _tuples_title_cpe = extract_full_names_to_cpe(xml_path)


def from_full_software_info_get_cep_text(software_info, force_lookup=False):
    global _tuples_title_cpe
    assert isinstance(_tuples_title_cpe, list)
    software_name = software_info.split("___")[0]
    software_version = software_info.split("___")[1]
    cpe_found_from_current_dataset = use_software_name_and_version_to_get_cpe_info_from_available_dataset(software_name,software_version)
    if not cpe_found_from_current_dataset:
        if not force_lookup:
            return None
        return logic_lookup(software_info)
    if len(cpe_found_from_current_dataset) == 1:
        return cpe_found_from_current_dataset[0]
    return get_input_from_user(software_name,software_version,results_got=cpe_found_from_current_dataset)


def use_software_name_and_version_to_get_cpe_info_from_available_dataset(software_name, software_version):
    global _tuples_title_cpe
    filtered_by_name = [x for x in _tuples_title_cpe if software_name.lower() in x[0].lower()]
    # software version maybe to long
    steps = len(software_version)
    while steps:
        version_num = software_version[:steps+1]
        filtered_by_version = [x for x in filtered_by_name if x[1].split(":")[4] == version_num]
        if len(filtered_by_version) > 0:
            return filtered_by_version
        steps -= 1



def search_cve_from_full_software_name_and_version(software_info):
    cpe_name = from_full_software_info_get_cep_text(software_info)
    out = search_product(cpe_name)
    print(out)


def get_list_of_softwares_with_full_name_and_version(file_path):
    df_input = pd.read_csv(file_path, encoding="utf-16")
    df_input["Name_cleaned"] = df_input.apply(lambda x: re.sub(r"-\s*$","",x["Name"].replace(x["Version"],"")),axis=1)
    return list((df_input["Name_cleaned"] + "___" + df_input["Version"]).values)


def logic_lookup(software_info):
    global _tuples_title_cpe
    software_name = software_info   .split("___")[0]
    software_version = software_info.split("___")[1]
    print(f"WARNING!!! The full software name: '{software_name}' was not found in the provided DB.")
    print("Trying to understand it ......")
    name_splits = software_name.split()
    if len(name_splits) == 1:
        return None # nothing to try
   # nums_of_words_matching_from_start = [sum([a==name_splits[i] for i,a in enumerate(x[0].split()) if i < len(name_splits)]) for x in _tuples_title_cpe]
    num_words_to_compare = len(name_splits) - 1
    cpe_found = False
    print(f"Starting from: {software_name}")
    print(f"Words that comprise it {name_splits}")
    print("We try to find the match removing one word at a time starting from the rightmost one.")
    potential_results = None
    minimum_number_of_words = 3
    while not cpe_found and num_words_to_compare >= minimum_number_of_words:
        print(f"Considering {num_words_to_compare} words! Namely:")
        print(f"{' '.join(name_splits[:num_words_to_compare])}")
        filtered_values = [x for x in _tuples_title_cpe if ' '.join(name_splits[:num_words_to_compare]) in x[0]]
        if len(filtered_values) > 0:
            potential_results = filtered_values
            cpe_found = True
        num_words_to_compare -= 1

    if cpe_found:
        print("We have found potential software.")
        print("Please follow the instructions.")
    return get_input_from_user(software_name, software_version, potential_results)

    # nums_of_words_matching_from_start = [sum([a==name_splits[i] for i,a in enumerate(x[0].split()) if i < len(name_splits)]) for x in _tuples_title_cpe]
    # num_words_to_compare = len(name_splits) - 1
    # cpe_found = False
    # print(f"Starting from: {software_name}")
    # name_splits = software_name.split()
    # print(f"Words that comprise it {name_splits}")
    # print("We try to find the match removing one word at a time starting from the right most one.")
    # potential_results = None
    # while not cpe_found and num_words_to_compare!=0:
    #     print(f"Considering {num_words_to_compare} words! Namely:")
    #     print(f"{' '.join(name_splits[:num_words_to_compare])}")
    #     idx = num_words_to_compare - 1
    #     indexes_of_interest = [i for i,x in enumerate(nums_of_words_matching_from_start) if x==idx]
    #     if indexes_of_interest:
    #         cpe_found = True
    #         potential_results = [_tuples_title_cpe[i] for i in indexes_of_interest]
    #     num_words_to_compare -= 1



def get_list_of_sw_with_cpe(software_list):
    not_transformed = []
    res = []
    for software_info in software_list:
        software_name = software_info   .split("___")[0]
        software_version = software_info.split("___")[1]
        cpe_text = from_full_software_info_get_cep_text(software_info,force_lookup=False)
        if cpe_text:
            res.append((software_name,software_version,cpe_text))
        debug = True
    return res


def repeatOnError(*exceptions):
    def checking(function):
        def checked(*args, **kwargs):
            while True:
                try:
                    result = function(*args, **kwargs)
                except exceptions as problem:
                    print("There was a problem with the input:")
                    print(problem.__class__.__name__)
                    print(problem)
                    print("Please repeat!")
                else:
                    return result
        return checked
    return checking


@repeatOnError(ValueError)
def get_input_from_user(software_name, software_version, results_got=None):
    global _tuples_title_cpe

    if not results_got:
        print(f"Nothing was found about the software '{software_name}' version: '{software_version}'")
        user_choice = int(input("Please enter 0 to skip this software or 1 to manually insert the cpe: "))
        if user_choice not in [0,1]:
            raise ValueError
        if user_choice == 1:
            user_cpe = input("Please enter 'vendor:product:version': ")
            filtered_list = [x[1] for x in _tuples_title_cpe if user_cpe in x[1]]
            if not filtered_list:
                raise ValueError("cpe not found! Try again!")
            return filtered_list[0]
        if user_choice == 0:
            return None
    print(f"The program was not able to find a cpe about the software '{software_name}' version: '{software_version}'!")
    print("Notwithstanding we present next potential values found in the dataset that may suit.")
    print("\n".join([f"[{i+1}]-{x}" for i, x in enumerate(results_got)]))
    print(f"Please if you find a match for '{software_name}' version: '{software_version}'"
          f" insert one of the above numbers.\nIf you want to skip this software, please enter 0\n"
          f"If you want to write the cpe manually, please enter 'cpe'")
    user_choice = input("Your choice: ")
    if user_choice.isdigit():
        if int(user_choice) not in range(len(results_got)+1):
            raise ValueError("Number inserted not valid!")
        if int(user_choice) == 0:
            return None
        return results_got[int(user_choice)-1]
    if user_choice!='cpe':
        raise ValueError
    user_cpe = input("Please enter 'vendor:product:version': ")
    filtered_list = [x[1] for x in _tuples_title_cpe if user_cpe in x[1]]
    if not filtered_list:
        raise ValueError("cpe not found! Try again!")
    return filtered_list[0]



if __name__ == "__main__":
    software_lists = get_list_of_softwares_with_full_name_and_version(os.path.join("data", "installed_progs.txt"))
    load_info_from_xml(os.path.join("data", "official-cpe-dictionary_v2.3.xml"))
    cpe_info = get_list_of_sw_with_cpe(software_lists)
    #cpe_names = [from_full_software_info_get_cep_text(x) for x in software_lists]
    print("We are going to search for the following list of software:")
    print("\n".join([f"{x}" for x in cpe_info]))
    debug = True
